# -*- coding: utf-8 -*-
"""Predicting Heart Disease with Classification ML Algorithms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mnmv-mnORfUYPY-1Uft0Ebg2gs_TwCyj

Data Wrangling
"""

import numpy as np
import pandas as pd
import matplotlib as plt
import seaborn as sns
import matplotlib.pyplot as plt
filePath ='heart.csv'

data = pd.read_csv(filePath)

data.head(5)

print("(Rows, columns): " + str(data.shape))
data.columns

"""summarizes the count, mean, standard deviation, min, and max for numeric variables."""

data.describe()

"""Checking for missing/null values"""

print(data.isna().sum())

"""Exploratory Data Analysis
Correlation Matrix- letâ€™s us see correlations between all variables.
"""

corr = data.corr()
plt.subplots(figsize=(15,10))
sns.heatmap(corr, xticklabels=corr.columns, yticklabels=corr.columns, annot=True, cmap=sns.diverging_palette(220, 20, as_cmap=True))
sns.heatmap(corr, xticklabels=corr.columns,
            yticklabels=corr.columns, 
            annot=True,
            cmap=sns.diverging_palette(220, 20, as_cmap=True))

"""Prepare Data for Modeling"""

X = data.iloc[:, :-1].values
y = data.iloc[:, -1].values

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,y,test_size = 0.2, random_state = 1)

"""Normalization"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
x_train = sc.fit_transform(x_train)
x_test = sc.transform(x_test)

features = np.array([[5, 2.9, 1, 0.2]])

"""Model 1: Logistic Regression"""

from sklearn.metrics import classification_report 
from sklearn.linear_model import LogisticRegression

model1 = LogisticRegression(random_state=1)
model1.fit(x_train, y_train) 

y_pred1 = model1.predict(x_test)
print(classification_report(y_test, y_pred1))

"""Model 2: K-NN (K-Nearest Neighbors)"""

from sklearn.metrics import classification_report 
from sklearn.neighbors import KNeighborsClassifier

model2 = KNeighborsClassifier() 
model2.fit(x_train, y_train)

y_pred2 = model2.predict(x_test) # get y predictions
print(classification_report(y_test, y_pred2)) # output accuracy

"""Model 3: Naives Bayes Classifier"""

from sklearn.metrics import classification_report 
from sklearn.naive_bayes import GaussianNB

model3 = GaussianNB() 
model3.fit(x_train, y_train) 

y_pred3 = model3.predict(x_test) 
print(classification_report(y_test, y_pred3))

"""Model 4: SVM (Support Vector Machine)"""

from sklearn.metrics import classification_report 
from sklearn.svm import SVC

model4 = SVC(random_state=1) 
model4.fit(x_train, y_train)  

y_pred4 = model4.predict(x_test) 
print(classification_report(y_test, y_pred4))

"""Model 5: Decision Trees"""

from sklearn.metrics import classification_report 
from sklearn.tree import DecisionTreeClassifier

model5 = DecisionTreeClassifier(random_state=1) 
model5.fit(x_train, y_train) 

y_pred5 = model5.predict(x_test) 
print(classification_report(y_test, y_pred5))

"""Model 6: Random Forest """

from sklearn.metrics import classification_report 
from sklearn.ensemble import RandomForestClassifier

model6 = RandomForestClassifier(random_state=1)
model6.fit(x_train, y_train)  

y_pred6 = model6.predict(x_test) 
print(classification_report(y_test, y_pred6))

"""Making Confusion Matrix:
---
A confusion matrix is a table that is used to define the performance of 
a classification algorithm and  visualizes and summarizes the performance of a classification algorithm.
"""

from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(y_test, y_pred4)
print(cm)
accuracy_score(y_test, y_pred4)

"""Feature Importance

"""

importance = model6.feature_importances_

# summarize feature importance
for i,v in enumerate(importance):
    print('Feature: %0d, Score: %.5f' % (i,v))

index= data.columns[:-1]
importance = pd.Series(model6.feature_importances_, index=index)
importance.nlargest(13).plot(kind='barh', colormap='winter')

"""Prediction """

print(model6.predict(sc.transform([[20,1,2,110,230,1,1,140,1,2.2,2,0,2]])))

print(model6.predict(sc.transform([[21,1,3,100,190,0,0,195,0,2.2,1,2,3]])))